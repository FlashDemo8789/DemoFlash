#!/usr/bin/env python3
"""
GENERATE:
  • backend/schemas.py        – Pydantic v2 model with hard required fields
  • backend/feature_map.py    – Ordered feature list for the ML layer
  • frontend/public/schema.json – Same JSON for the React wizard

Run:  python generators/build_schema.py [--contract path/to/contract.json]
Re-run whenever contracts/metrics.json changes.
"""

from __future__ import annotations

import json, pathlib, datetime, textwrap, hashlib, argparse
from decimal import Decimal

ROOT   = pathlib.Path(__file__).resolve().parents[1]
DEFAULT_SPEC = ROOT / "contracts" / "metrics.json"
DST_PY = ROOT / "backend"   / "schemas.py"
DST_FM = ROOT / "backend"   / "feature_map.py"
DST_FE = ROOT / "frontend"  / "public" / "schema.json"

TYPE_MAP = {
    "string":   "str",
    "integer":  "int",
    "number":   "float",
    "boolean":  "bool",
    "array":    "list[str]",
    "currency": "Decimal"
}

def render_field(name: str, meta: dict) -> str:
    """Return a single line of `name: type = Field(...)`."""
    py_type   = TYPE_MAP[meta["type"]]
    ann       = py_type if meta.get("required") else f"Optional[{py_type}]"
    default   = "..." if meta.get("required") else meta.get("default", "None")
    desc      = meta.get("description", "")
    kwargs  = []
    # Numeric validations
    if meta["type"] in {"integer", "number", "currency"}:
        kwargs.append("ge=0")
    if meta["type"] == "string" and meta.get("maxLength"):
        kwargs.append(f"max_length={meta['maxLength']}")
    kwarg_str = (", " + ", ".join(kwargs)) if kwargs else ""
    # Use original name for Python field, assuming it's valid identifier
    # If not, snake_case conversion might be needed, but assume valid for now
    field_name = name # Use the key from JSON directly as field name
    return f"    {field_name}: {ann} = Field({default}, description={desc!r}{kwarg_str})"

def checksum(path: pathlib.Path) -> str:
    return hashlib.sha256(path.read_bytes()).hexdigest()[:8]

def parse_args():
    parser = argparse.ArgumentParser(description="Generate schemas from contract file")
    parser.add_argument("--contract", type=str, help="Path to contract JSON file")
    return parser.parse_args()

def main() -> None:
    args = parse_args()
    spec_path = pathlib.Path(args.contract) if args.contract else DEFAULT_SPEC
    
    if not spec_path.exists():
        print(f"Error: Contract file not found at {spec_path}. Please create it.")
        exit(1)

    try:
        spec = json.loads(spec_path.read_text())
        if not isinstance(spec, dict):
             print(f"Error: {spec_path} must contain a JSON object.")
             exit(1)
    except json.JSONDecodeError as e:
        print(f"Error reading {spec_path}: {e}")
        exit(1)

    # Ensure critical fields are present in the spec
    critical_fields = ["startup_id"]
    for field in critical_fields:
        if field not in spec:
            print(f"Adding missing critical field '{field}' to spec")
            spec[field] = {
                "type": "string", 
                "required": True, 
                "description": "Unique identifier for the startup"
            }

    # Ensure output directories exist
    DST_PY.parent.mkdir(parents=True, exist_ok=True)
    DST_FM.parent.mkdir(parents=True, exist_ok=True)
    DST_FE.parent.mkdir(parents=True, exist_ok=True)

    # ── build schemas.py ────────────────────────────────────────────────────
    py_lines: list[str] = [
        "# AUTO-GENERATED by generators/build_schema.py — DO NOT EDIT",
        f"# Generated on: {datetime.datetime.utcnow().isoformat()}Z",
        f"# Source: {spec_path}",
        f"# Spec Checksum: {checksum(spec_path)}",
        "from __future__ import annotations",
        "from typing import Optional, List",
        "from decimal import Decimal",
        "from pydantic import BaseModel, Field, model_validator",
        "",
        "class MetricsInput(BaseModel):",
        "    \"\"\"Input model generated from contracts/metrics.json\"\"\""
    ]
    feature_keys: list[str] = []
    schema_fields: list[str] = []

    for name, meta in spec.items():
        typ = meta.get("type")
        if typ is None:
            raise ValueError(f"[build_schema] '{name}' missing 'type' in {spec_path}")

        # ---------------- array handling ----------------
        if typ == "array":
            # backend only needs numeric len; store as <field>_len
            feature_keys.append(f"{name}_len")
            schema_fields.append(f"{name}: list[str] | None = None")
            continue
        # ------------------------------------------------

        feature_keys.append(name)
        # Add field definition line
        py_lines.append(render_field(name, meta))

    # Add model validator
    validator_code = textwrap.dedent("""
        @model_validator(mode="after")
        def _logical_invariants(self):
            # Runway = Cash / Burn  (±1 month tolerance)
            if (
                getattr(self, 'cash_on_hand_usd', None) is not None and
                getattr(self, 'monthly_burn_usd', None) is not None and
                getattr(self, 'runway_months', None) is not None and
                self.monthly_burn_usd > 0 # Avoid division by zero
            ):
                expected = Decimal(self.cash_on_hand_usd) / Decimal(self.monthly_burn_usd)
                if abs(expected - Decimal(self.runway_months)) > 1.0:
                    raise ValueError(f"runway_months ({self.runway_months}) inconsistent with cash ({self.cash_on_hand_usd}) / burn ({self.monthly_burn_usd}). Expected ~{expected:.1f}")

            # debt_ratio must be 0-1
            debt_ratio_val = getattr(self, 'debt_ratio', None)
            if debt_ratio_val is not None and not (0 <= debt_ratio_val <= 1):
                raise ValueError(f"debt_ratio ({debt_ratio_val}) must be between 0 and 1")

            # Team size consistency example (adapt as needed)
            team_total = getattr(self, 'team_size_total', None)
            full_time = getattr(self, 'team_size_full_time', None)
            if team_total is not None and full_time is not None and full_time > team_total:
                raise ValueError(f"team_size_full_time ({full_time}) cannot exceed team_size_total ({team_total})")

            return self
    """)
    py_lines.append(textwrap.indent(validator_code, "    "))

    # Add model config (indented)
    model_config_code = textwrap.dedent("""
        # Class-level configuration
        model_config = {
            "extra": "ignore", # Allow extra fields
            "validate_assignment": True # Revalidate on attribute assignment
        }
    """)
    py_lines.append(textwrap.indent(model_config_code, "    "))

    DST_PY.write_text("\n".join(py_lines) + "\n")

    # Add RunwaySimInput class definition manually to the generated output
    runway_sim_input_code = textwrap.dedent("""
        # Define a simpler model specifically for runway simulation input
        class RunwaySimInput(BaseModel):
            startup_id: Optional[str] = None
            total_funding_usd: Optional[Decimal] = Field(None, ge=0)
            monthly_burn_usd: Decimal = Field(..., ge=0) # Burn rate is required
            cash_on_hand_usd: Decimal = Field(..., ge=0) # Cash on hand is required

            model_config = {"extra": "ignore"}
        """)
    # Append this code to the file content after writing py_lines
    with open(DST_PY, "a") as f:
        f.write("\n" + runway_sim_input_code + "\n")

    # ── build feature_map.py ───────────────────────────────────────────────
    DST_FM.write_text(textwrap.dedent(f"""\
        \"\"\"AUTOGENERATED list of ML feature names (length {len(feature_keys)})\"\"\"
        FEATURES = {feature_keys!r}
        """))

    # ── copy schema.json for the frontend wizard ───────────────────────────
    DST_FE.write_text(json.dumps(spec, indent=2) + "\n")

    print(f"✨ Schema build complete. Generated:\n - {DST_PY}\n - {DST_FM}\n - {DST_FE}")

if __name__ == "__main__":
    main() 